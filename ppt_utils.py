from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
import os
import requests
from io import BytesIO
import concurrent.futures
import urllib.parse
from datetime import datetime

# --- Constants & Theme ---
THEME_FONT = "Calibri" 
TITLE_SIZE = Pt(60)          # Main Title (Cover)
SUBTITLE_SIZE = Pt(32)       # Subtitle (Cover)
SLIDE_HEADING_SIZE = Pt(44)  # Slide Title (Standard: 36-44pt)
BODY_SIZE_L0 = Pt(28)        # Level 1 Bullets (Standard: 24-28pt)
BODY_SIZE_L1 = Pt(24)        # Level 2 Bullets (Standard: 20-24pt)
BODY_SIZE_L2 = Pt(20)        # Level 3 Bullets (Standard: 16-20pt)
COLOR_PRIMARY = RGBColor(14, 42, 71)    # Dark Navy
COLOR_ACCENT = RGBColor(0, 150, 136)    # Teal
COLOR_TEXT_MAIN = RGBColor(64, 64, 64)  # Dark Gray
COLOR_TEXT_LIGHT = RGBColor(117, 117, 117) # Medium Gray
COLOR_BACKGROUND = RGBColor(250, 250, 250) # Off-white/Light Gray
# Layout Constants
SLIDE_WIDTH = Inches(13.333)
SLIDE_HEIGHT = Inches(7.5)
MARGIN_LEFT = Inches(1)
MARGIN_RIGHT = Inches(1)
MARGIN_TOP = Inches(0.5) # For Title
MARGIN_BOTTOM = Inches(0.5)

def fetch_image(query):
    """
    Fetches an image stream for a given query.
    Returns BytesIO object or None.
    """
    if not query:
        return None
        
    try:
        safe_query = urllib.parse.quote(query)
        # Higher resolution placeholder
        image_url = f"https://placehold.co/800x600?text={safe_query}"
        
        response = requests.get(image_url, timeout=5)
        if response.status_code == 200:
            return BytesIO(response.content)
    except Exception as e:
        print(f"Error fetching image for '{query}': {e}")
    
    return None

def apply_slide_footer(slide, slide_number, presentation_title):
    """Adds a footer with date, title, and slide number."""
    # Date
    date_str = datetime.now().strftime("%B %d, %Y")
    
    # We can use the slide master placeholders if available, but for robustness
    # we'll add text boxes to the bottom.
    
    # 1. Slide Number (Bottom Right)
    width = Inches(1)
    height = Inches(0.5)
    left = Inches(13.333) - width - Inches(0.2) # Assuming 16:9 aspect ratio standard (13.333 inches wide)
    top = Inches(7.5) - height # Assuming 7.5 inches height
    
    txBox = slide.shapes.add_textbox(left, top, width, height)
    tf = txBox.text_frame
    p = tf.paragraphs[0]
    p.text = str(slide_number)
    p.font.size = Pt(12)
    p.font.color.rgb = COLOR_TEXT_LIGHT
    p.alignment = PP_ALIGN.RIGHT

    # 2. Footer Text (Bottom Left) - Title & Date
    width = Inches(8)
    left = MARGIN_LEFT
    
    txBox2 = slide.shapes.add_textbox(left, top, width, height)
    tf2 = txBox2.text_frame
    p2 = tf2.paragraphs[0]
    p2.text = f"{presentation_title} | {date_str}"
    p2.font.size = Pt(12)
    p2.font.color.rgb = COLOR_TEXT_LIGHT
    p2.alignment = PP_ALIGN.LEFT

def create_ppt(data, filename="generated_presentation.pptx", image_mode=None):
    """
    Creates a professional PowerPoint presentation.
    """
    prs = Presentation()
    # Set to widescreen 16:9 if not default (pptx default is usually 4:3 or 16:9 depending on template, we assume standard)
    prs.slide_width = Inches(13.333)
    prs.slide_height = Inches(7.5)

    presentation_title = data.get("title", "Untitled Presentation")

    # --- helper: apply title formatting ---
    def format_slide_title(shape, text):
        shape.text = text
        tf = shape.text_frame
        tf.vertical_anchor = MSO_ANCHOR.BOTTOM
        p = tf.paragraphs[0]
        p.font.bold = True
        p.font.size = SLIDE_HEADING_SIZE
        p.font.name = THEME_FONT
        p.font.color.rgb = COLOR_PRIMARY
        p.alignment = PP_ALIGN.LEFT
        
        # Add a colored accent line under title (simulated with underscores or a shape if we wanted to get fancy)
        # For now, clean text is better.

    # 1. Title Slide
    title_slide_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    
    # Set background color
    background = slide.background
    fill = background.fill
    fill.solid()
    fill.fore_color.rgb = COLOR_BACKGROUND
    
    title = slide.shapes.title
    subtitle = slide.placeholders[1]

    # Main Title Formatting
    title.text = presentation_title
    tf = title.text_frame
    p = tf.paragraphs[0]
    p.font.bold = True
    p.font.size = TITLE_SIZE
    p.font.name = THEME_FONT
    p.font.color.rgb = COLOR_PRIMARY
    p.alignment = PP_ALIGN.CENTER

    subtitle.text = "Generated by Gemini AI"
    sf = subtitle.text_frame
    sp = sf.paragraphs[0]
    sp.font.size = SUBTITLE_SIZE
    sp.font.name = THEME_FONT
    sp.font.color.rgb = COLOR_ACCENT
    sp.alignment = PP_ALIGN.CENTER

    # 2. Pre-fetch Images (Parallel)
    # ... logic relies on having the final list of slides, so we paginate FIRST.

    # --- helper: Paginate Slides ---
    def paginate_slides(original_slides):
        paginated = []
        
        # Height constants (approximate based on 7.5" total height)
        # Top margin ~1.5" (Title) + Bottom margin ~0.5" (Footer) = ~2.0" used
        # Usable height for body = 7.5 - 2.0 = 5.5 inches
        # Let's use points. 1 inch = 72 pt. 5.5 inches = 396 pt.
        # Conservative limit to ensure fit (reduced to prevent overlap with footer)
        MAX_HEIGHT_PT = 300  
        
        # Character widths (approximate for Calibri)
        # Full width (no image): ~12 inches usable width
        # Half width (with image): ~6 inches usable width
        # Average char width for body text (approx) -> distinct from line counting
        # simple heuristic: chars_per_line = usable_width_inches * chars_per_inch
        # chars_per_inch ~ 12 (for 12pt), for 28pt it's much less.
        # Let's keep using char counts for wrapping estimation:
        CHARS_PER_LINE_FULL = 60 # Approx for wide layout
        CHARS_PER_LINE_HALF = 30 # Approx for two-column layout (narrower than before to be safe)

        # Content constants
        # Leading/Margins per item (space before/after)
        ITEM_SPACING_PT = {
            0: 16, # 10 before + 6 after
            1: 12, # 6 before + 6 after
            2: 8   # 4 before + 4 after
        }
        FONT_SIZE_PT = {
            0: 28,
            1: 24,
            2: 20
        }

        for slide_data in original_slides:
            content_items = slide_data.get("content", [])
            # Handle bullet_points fallback if present
            if not content_items and "bullet_points" in slide_data:
                content_items = [{"text": bp, "level": 0} for bp in slide_data["bullet_points"]]
                
            if not content_items:
                paginated.append(slide_data)
                continue

            # Determine layout width for estimation using outer scope image_mode
            is_half_width = image_mode in ['manual', 'auto']
            chars_limit = CHARS_PER_LINE_HALF if is_half_width else CHARS_PER_LINE_FULL

            current_slide_items = []
            current_height = 0
            
            def estimate_text_height(text, level, width_chars):
                if not text: return 0
                lines = max(1, len(text) // width_chars + (1 if len(text) % width_chars > 0 else 0))
                # Height = (lines * font_size * line_height_factor) + spacing
                # Default line height is ~1.2
                line_height = FONT_SIZE_PT.get(level, 24) * 1.2
                total_text_height = lines * line_height
                spacing = ITEM_SPACING_PT.get(level, 10)
                return total_text_height + spacing

            for item in content_items:
                text = item.get("text", "")
                level = item.get("level", 0)
                
                item_height = estimate_text_height(text, level, chars_limit)
                
                # Check if adding this item exceeds max height
                # If it's the FIRST item, we must add it even if it's huge (or it will loop forever)
                if current_height + item_height > MAX_HEIGHT_PT and current_slide_items:
                    # Push current slide
                    new_slide = slide_data.copy()
                    new_slide["content"] = current_slide_items
                    paginated.append(new_slide)
                    
                    # Reset for next slide
                    current_slide_items = [item]
                    current_height = item_height
                else:
                    current_slide_items.append(item)
                    current_height += item_height
            
            # Append the last chunk
            if current_slide_items:
                new_slide = slide_data.copy()
                new_slide["content"] = current_slide_items
                # If we split this slide (i.e. paginated had entries from this slide loop already),
                # we might want to mark continuation.
                
                base_title = slide_data.get("heading", "")
                
                # Check if we already added a part of this slide
                if len(paginated) > 0 and paginated[-1].get("heading").replace(" (Cont.)", "") == base_title.replace(" (Cont.)", ""):
                     new_slide["heading"] = f"{base_title} (Cont.)"
                     # Remove image requirement for continuation slides to save space/redundancy
                     if "image_search_query" in new_slide:
                         del new_slide["image_search_query"]

                paginated.append(new_slide)

        return paginated

    # 3. Process Slides (Paginate & Fetch)
    
    # Run pagination
    final_slides_data = paginate_slides(data.get("slides", []))
    
    image_map = {}
    
    if image_mode == 'auto':
        print(f"Fetching images for {len(final_slides_data)} slides in parallel...")
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            # Prepare queries
            future_to_index = {}
            for i, slide_data in enumerate(final_slides_data):
                query = slide_data.get("image_search_query", slide_data.get("heading", ""))
                # Only fetch if we have a query
                if query:
                     future = executor.submit(fetch_image, query)
                     future_to_index[future] = i
            
            for future in concurrent.futures.as_completed(future_to_index):
                idx = future_to_index[future]
                try:
                    image_stream = future.result()
                    if image_stream:
                        image_map[idx] = image_stream
                except Exception as exc:
                    print(f"Image fetch generated an exception for slide {idx}: {exc}")

    # 4. Content Slides Generation
    for i, slide_data in enumerate(final_slides_data):
        
        use_image_layout = image_mode in ['manual', 'auto']
        
        # Use appropriate layouts. 
        # Layout 1 is "Title and Content"
        # Layout 3 is "Two Content" (Side by side)
        if use_image_layout:
             slide_layout = prs.slide_layouts[3] 
        else:
             slide_layout = prs.slide_layouts[1] 

        slide = prs.slides.add_slide(slide_layout)
        
        # Apply standard background
        background = slide.background
        fill = background.fill
        fill.solid()
        fill.fore_color.rgb = COLOR_BACKGROUND

        shapes = slide.shapes

        # Title
        title_shape = shapes.title
        format_slide_title(title_shape, slide_data.get("heading", "No Title"))
        
        # Enforce Title Alignment & Size
        title_shape.left = MARGIN_LEFT
        title_shape.top = MARGIN_TOP
        title_shape.width = SLIDE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT
        title_shape.height = Inches(1.3)

        # Footer
        apply_slide_footer(slide, i + 1, presentation_title)

        # Body (Bullet points)
        # In Layout 3 (Two Content), placeholder[1] is Left, [2] is Right.
        # In Layout 1 (Title/Content), placeholder[1] is the main body.
        
        body_shape = shapes.placeholders[1]
        
        # Enforce Body Alignment & Size
        body_shape.left = MARGIN_LEFT
        body_shape.top = MARGIN_TOP + Inches(1.3) + Inches(0.2) # Below title
        
        if use_image_layout:
             # Half width (adjust slightly to leave gap)
             body_shape.width = int((SLIDE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT) / 2)
        else:
             # Full width
             body_shape.width = SLIDE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT
             
        body_shape.height = SLIDE_HEIGHT - body_shape.top - MARGIN_BOTTOM - Inches(0.5) # Space for footer
        
        tf = body_shape.text_frame
        tf.clear() 
        tf.word_wrap = True

        # Content 
        content = slide_data.get("content", [])
        if not content and "bullet_points" in slide_data:
            content = [{"text": bp, "level": 0} for bp in slide_data["bullet_points"]]

        if content:
            for item in content:
                text = item.get("text", "")
                level = item.get("level", 0)
                
                p = tf.add_paragraph()
                p.text = text
                p.level = level
                p.font.name = THEME_FONT
                p.alignment = PP_ALIGN.LEFT
                
                # Pro Typography & Hierarchy
                if level == 0:
                    p.font.size = BODY_SIZE_L0 
                    p.font.bold = False 
                    p.font.color.rgb = COLOR_TEXT_MAIN
                    p.space_before = Pt(12) 
                    p.space_after = Pt(6)
                elif level == 1:
                    p.font.size = BODY_SIZE_L1
                    p.font.color.rgb = COLOR_TEXT_LIGHT
                    p.space_before = Pt(6)
                    p.space_after = Pt(6)
                else:
                    p.font.size = BODY_SIZE_L2
                    p.font.color.rgb = COLOR_TEXT_LIGHT
                    p.space_before = Pt(4)
                    p.space_after = Pt(4)

        # Image Handling
        # If Two Content layout, image goes to placeholder[2]
        if use_image_layout and image_mode == 'auto':
            if i in image_map:
                try:
                    if len(shapes.placeholders) > 2:
                        image_placeholder = shapes.placeholders[2]
                        image_stream = image_map[i]
                        image_stream.seek(0)
                        
                        image_placeholder.insert_picture(image_stream)
                        # Crop logic could be added here if needed, but insert_picture usually fits well.
                        
                except Exception as e:
                    print(f"Error inserting image for slide {i}: {e}")
            elif len(shapes.placeholders) > 2:
                 pass # Empty placeholder remains

    # Ensure output directory exists
    output_path = os.path.abspath(filename)
    prs.save(output_path)
    return output_path
