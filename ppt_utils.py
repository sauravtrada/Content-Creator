from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
import os
import requests
from io import BytesIO
import concurrent.futures
import urllib.parse
from datetime import datetime

# --- Constants & Theme ---
THEME_FONT = "Calibri" 
TITLE_SIZE = Pt(60)          # Main Title (Cover)
SUBTITLE_SIZE = Pt(32)       # Subtitle (Cover)
SLIDE_HEADING_SIZE = Pt(44)  # Slide Title (Standard: 36-44pt)
BODY_SIZE_L0 = Pt(22)        # Level 1 Bullets (Reduced)
BODY_SIZE_L1 = Pt(18)        # Level 2 Bullets (Reduced)
BODY_SIZE_L2 = Pt(16)        # Level 3 Bullets (Reduced)
COLOR_PRIMARY = RGBColor(14, 42, 71)    # Dark Navy
COLOR_ACCENT = RGBColor(0, 150, 136)    # Teal
COLOR_TEXT_MAIN = RGBColor(64, 64, 64)  # Dark Gray
COLOR_TEXT_LIGHT = RGBColor(117, 117, 117) # Medium Gray
COLOR_BACKGROUND = RGBColor(250, 250, 250) # Off-white/Light Gray
# Layout Constants
SLIDE_WIDTH = Inches(13.333)
SLIDE_HEIGHT = Inches(7.5)
MARGIN_LEFT = Inches(1)
MARGIN_RIGHT = Inches(1)
MARGIN_TOP = Inches(0.5) # For Title
MARGIN_BOTTOM = Inches(0.5)

def fetch_image(query):
    """
    Fetches an image stream for a given query.
    Returns BytesIO object or None.
    """
    if not query:
        return None
        
    try:
        safe_query = urllib.parse.quote(query)
        # Higher resolution placeholder
        image_url = f"https://placehold.co/800x600?text={safe_query}"
        
        response = requests.get(image_url, timeout=5)
        if response.status_code == 200:
            return BytesIO(response.content)
    except Exception as e:
        print(f"Error fetching image for '{query}': {e}")
    
    return None

def apply_slide_footer(slide, slide_number, presentation_title):
    """Adds a footer with date, title, and slide number."""
    # Date
    date_str = datetime.now().strftime("%B %d, %Y")
    
    # We can use the slide master placeholders if available, but for robustness
    # we'll add text boxes to the bottom.
    
    # 1. Slide Number (Bottom Right)
    width = Inches(1)
    height = Inches(0.5)
    left = Inches(13.333) - width - Inches(0.2) # Assuming 16:9 aspect ratio standard (13.333 inches wide)
    top = Inches(7.5) - height # Assuming 7.5 inches height
    
    txBox = slide.shapes.add_textbox(left, top, width, height)
    tf = txBox.text_frame
    p = tf.paragraphs[0]
    p.text = str(slide_number)
    p.font.size = Pt(12)
    p.font.color.rgb = COLOR_TEXT_LIGHT
    p.alignment = PP_ALIGN.RIGHT

    # 2. Footer Text (Bottom Left) - Title & Date
    width = Inches(8)
    left = MARGIN_LEFT
    
    txBox2 = slide.shapes.add_textbox(left, top, width, height)
    tf2 = txBox2.text_frame
    p2 = tf2.paragraphs[0]
    p2.text = f"{presentation_title} | {date_str}"
    p2.font.size = Pt(12)
    p2.font.color.rgb = COLOR_TEXT_LIGHT
    p2.alignment = PP_ALIGN.LEFT

def create_ppt(data, filename="generated_presentation.pptx", image_mode=None):
    """
    Creates a professional PowerPoint presentation.
    """
    prs = Presentation()
    # Set to widescreen 16:9 if not default (pptx default is usually 4:3 or 16:9 depending on template, we assume standard)
    prs.slide_width = Inches(13.333)
    prs.slide_height = Inches(7.5)

    presentation_title = data.get("title", "Untitled Presentation")

    # --- helper: apply title formatting ---
    def format_slide_title(shape, text):
        shape.text = text
        tf = shape.text_frame
        tf.vertical_anchor = MSO_ANCHOR.BOTTOM
        p = tf.paragraphs[0]
        p.font.bold = True
        p.font.size = SLIDE_HEADING_SIZE
        p.font.name = THEME_FONT
        p.font.color.rgb = COLOR_PRIMARY
        p.alignment = PP_ALIGN.LEFT
        
        # Add a colored accent line under title (simulated with underscores or a shape if we wanted to get fancy)
        # For now, clean text is better.

    # 1. Title Slide
    title_slide_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    
    # Set background color
    background = slide.background
    fill = background.fill
    fill.solid()
    fill.fore_color.rgb = COLOR_BACKGROUND
    
    title = slide.shapes.title
    subtitle = slide.placeholders[1]

    # Main Title Formatting
    title.text = presentation_title
    tf = title.text_frame
    p = tf.paragraphs[0]
    p.font.bold = True
    p.font.size = TITLE_SIZE
    p.font.name = THEME_FONT
    p.font.color.rgb = COLOR_PRIMARY
    p.alignment = PP_ALIGN.CENTER

    subtitle.text = "Generated by Gemini AI"
    sf = subtitle.text_frame
    sp = sf.paragraphs[0]
    sp.font.size = SUBTITLE_SIZE
    sp.font.name = THEME_FONT
    sp.font.color.rgb = COLOR_ACCENT
    sp.alignment = PP_ALIGN.CENTER

    # 2. Pre-fetch Images (Parallel)
    # ... logic relies on having the final list of slides, so we paginate FIRST.

    # Smart pagination removed by user request.
    # We now strictly map 1 slide from the outline to 1 slide in the PPT.

    # 3. Process Slides (Fetch Only)
    
    # Use slides directly without pagination
    final_slides_data = data.get("slides", [])
    
    image_map = {}
    
    if image_mode == 'auto':
        print(f"Fetching images for {len(final_slides_data)} slides in parallel...")
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            # Prepare queries
            future_to_index = {}
            for i, slide_data in enumerate(final_slides_data):
                query = slide_data.get("image_search_query", slide_data.get("heading", ""))
                # Only fetch if we have a query
                if query:
                     future = executor.submit(fetch_image, query)
                     future_to_index[future] = i
            
            for future in concurrent.futures.as_completed(future_to_index):
                idx = future_to_index[future]
                try:
                    image_stream = future.result()
                    if image_stream:
                        image_map[idx] = image_stream
                except Exception as exc:
                    print(f"Image fetch generated an exception for slide {idx}: {exc}")

    # 4. Content Slides Generation
    for i, slide_data in enumerate(final_slides_data):
        
        use_image_layout = image_mode in ['manual', 'auto']
        
        # Use appropriate layouts. 
        # Layout 1 is "Title and Content"
        # Layout 3 is "Two Content" (Side by side)
        if use_image_layout:
             slide_layout = prs.slide_layouts[3] 
        else:
             slide_layout = prs.slide_layouts[1] 

        slide = prs.slides.add_slide(slide_layout)
        
        # Apply standard background
        background = slide.background
        fill = background.fill
        fill.solid()
        fill.fore_color.rgb = COLOR_BACKGROUND

        shapes = slide.shapes

        # Title
        title_shape = shapes.title
        format_slide_title(title_shape, slide_data.get("heading", "No Title"))
        
        # Enforce Title Alignment & Size
        title_shape.left = MARGIN_LEFT
        title_shape.top = MARGIN_TOP
        title_shape.width = SLIDE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT
        title_shape.height = Inches(1.3)

        # Footer
        apply_slide_footer(slide, i + 1, presentation_title)

        # Body (Bullet points)
        # In Layout 3 (Two Content), placeholder[1] is Left, [2] is Right.
        # In Layout 1 (Title/Content), placeholder[1] is the main body.
        
        body_shape = shapes.placeholders[1]
        
        # Enforce Body Alignment & Size
        body_shape.left = MARGIN_LEFT
        body_shape.top = MARGIN_TOP + Inches(1.3) + Inches(0.2) # Below title
        
        if use_image_layout:
             # Half width (adjust slightly to leave gap)
             body_shape.width = int((SLIDE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT) / 2)
        else:
             # Full width
             body_shape.width = SLIDE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT
             
        body_shape.height = SLIDE_HEIGHT - body_shape.top - MARGIN_BOTTOM - Inches(0.5) # Space for footer
        
        tf = body_shape.text_frame
        tf.clear() 
        tf.word_wrap = True

        # Content 
        content = slide_data.get("content", [])
        if not content and "bullet_points" in slide_data:
            content = [{"text": bp, "level": 0} for bp in slide_data["bullet_points"]]

        if content:
            for item in content:
                text = item.get("text", "")
                level = item.get("level", 0)
                
                p = tf.add_paragraph()
                p.text = text
                p.level = level
                p.font.name = THEME_FONT
                p.alignment = PP_ALIGN.LEFT
                
                # Pro Typography & Hierarchy
                if level == 0:
                    p.font.size = BODY_SIZE_L0 
                    p.font.bold = False 
                    p.font.color.rgb = COLOR_TEXT_MAIN
                    p.space_before = Pt(12) 
                    p.space_after = Pt(6)
                elif level == 1:
                    p.font.size = BODY_SIZE_L1
                    p.font.color.rgb = COLOR_TEXT_LIGHT
                    p.space_before = Pt(6)
                    p.space_after = Pt(6)
                else:
                    p.font.size = BODY_SIZE_L2
                    p.font.color.rgb = COLOR_TEXT_LIGHT
                    p.space_before = Pt(4)
                    p.space_after = Pt(4)

        # Image Handling
        # If Two Content layout, image goes to placeholder[2]
        if use_image_layout and image_mode == 'auto':
            if i in image_map:
                try:
                    if len(shapes.placeholders) > 2:
                        image_placeholder = shapes.placeholders[2]
                        image_stream = image_map[i]
                        image_stream.seek(0)
                        
                        image_placeholder.insert_picture(image_stream)
                        # Crop logic could be added here if needed, but insert_picture usually fits well.
                        
                except Exception as e:
                    print(f"Error inserting image for slide {i}: {e}")
            elif len(shapes.placeholders) > 2:
                 pass # Empty placeholder remains

    # Ensure output directory exists
    output_path = os.path.abspath(filename)
    prs.save(output_path)
    return output_path
